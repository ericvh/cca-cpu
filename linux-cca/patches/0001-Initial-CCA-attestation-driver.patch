diff --git a/arch/arm64/Kbuild b/arch/arm64/Kbuild
index 5bfbf7d79c99..4651ff2af206 100644
--- a/arch/arm64/Kbuild
+++ b/arch/arm64/Kbuild
@@ -4,6 +4,7 @@ obj-$(CONFIG_KVM)	+= kvm/
 obj-$(CONFIG_XEN)	+= xen/
 obj-$(subst m,y,$(CONFIG_HYPERV))	+= hyperv/
 obj-$(CONFIG_CRYPTO)	+= crypto/
+obj-$(CONFIG_CCA_ATTESTATION) += cca-attestation/
 
 # for cleaning
 subdir- += boot
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 20f3c861a2ec..b057eceb9e8b 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -2227,3 +2227,5 @@ source "arch/arm64/kvm/Kconfig"
 
 source "arch/arm64/kvm/Kconfig"
 
+
+source "arch/arm64/cca-attestation/Kconfig"
diff --git a/arch/arm64/cca-attestation/Kconfig b/arch/arm64/cca-attestation/Kconfig
new file mode 100644
index 000000000000..f19f31eecf50
--- /dev/null
+++ b/arch/arm64/cca-attestation/Kconfig
@@ -0,0 +1,3 @@
+config CCA_ATTESTATION
+	tristate "Driver for CCA Attestation"
+	default y
diff --git a/arch/arm64/cca-attestation/Makefile b/arch/arm64/cca-attestation/Makefile
new file mode 100644
index 000000000000..3b7d63c66d5d
--- /dev/null
+++ b/arch/arm64/cca-attestation/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the linux kernel.
+#
+
+obj-$(CONFIG_CCA_ATTESTATION) += cca-attestation.o
+
+cca-attestation-$(CONFIG_CCA_ATTESTATION) += module.o smc.o
diff --git a/arch/arm64/cca-attestation/module.c b/arch/arm64/cca-attestation/module.c
new file mode 100644
index 000000000000..dd213b29397c
--- /dev/null
+++ b/arch/arm64/cca-attestation/module.c
@@ -0,0 +1,370 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 ARM Ltd, All Rights Reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/mutex.h>
+#include <linux/fs.h>
+#include <asm/rsi.h>
+
+#include "smc-rsi.h"
+#include "rsi.h"
+#include "asm/rsi_cmds.h"
+
+#define DEVICE_CLASS "cca"
+#define DEVICE_NAME  "attestation"
+#define DEVICE_FILE  DEVICE_CLASS "_" DEVICE_NAME
+
+#define CCA_ATTESTATION_REQUEST_TOKEN _IOWR('A', 1, cca_ioctl_attestation_request_t)
+#define CCA_MEASUREMENT_EXTEND_TOKEN  _IOWR('A', 2, cca_ioctl_measurement_t)
+#define CCA_MEASUREMENT_READ_TOKEN    _IOWR('A', 3, cca_ioctl_measurement_t)
+
+// #define CCA_DEBUG
+
+static dev_t  dev = MKDEV(0, 0);
+static struct class *cca_class = NULL;
+static struct cdev attestation_dev;
+static DEFINE_MUTEX(cca_attestation_lock);
+static char cca_attestation_buf[4096] __attribute__((aligned(4096)));
+
+typedef struct cca_challenge {
+	union {
+		unsigned char as_char[64];
+		unsigned long as_long[8];
+	};
+} cca_challenge_t;
+
+typedef struct cca_buffer {
+	union {
+		unsigned char as_char[64];
+		unsigned long as_long[8];
+	};
+} cca_buffer_t;
+
+typedef struct cca_ioctl_attestation_request {
+	cca_challenge_t challenge;
+	unsigned char token[4096];
+	ssize_t token_length;
+} cca_ioctl_attestation_request_t;
+
+typedef struct cca_ioctl_measurement {
+	cca_buffer_t measurement;
+	unsigned long measurement_size;
+	unsigned long index;
+	unsigned long result;
+} cca_ioctl_measurement_t;
+
+static struct rsi_result rsi_invoke(unsigned int rsi_opcode,
+                                    unsigned long arg0, unsigned long arg1,
+                                    unsigned long arg2, unsigned long arg3,
+                                    unsigned long arg4, unsigned long arg5,
+                                    unsigned long arg6, unsigned long arg7,
+                                    unsigned long arg8, unsigned long arg9,
+                                    unsigned long arg10)
+{
+	struct rsi_result res;
+	struct smc_result smc_result;
+
+	smc_invoke_res(rsi_opcode, arg0, arg1, arg2, arg3, arg4, arg5, arg6,
+					arg7, arg8, arg9, arg10, &smc_result);
+
+	res.err_code = (unsigned int)smc_result.x0;
+	res.x1 = smc_result.x1;
+	res.x2 = smc_result.x2;
+	res.x3 = smc_result.x3;
+	res.x4 = smc_result.x4;
+	res.x5 = smc_result.x5;
+	res.x6 = smc_result.x6;
+	res.x7 = smc_result.x7;
+	res.x8 = smc_result.x8;
+	res.x9 = smc_result.x9;
+
+	return res;
+}
+
+static struct rsi_result
+get_attest_token(unsigned long buf,
+                unsigned long challenge_0, unsigned long challenge_1,
+                unsigned long challenge_2, unsigned long challenge_3,
+                unsigned long challenge_4, unsigned long challenge_5,
+                unsigned long challenge_6, unsigned long challenge_7)
+{
+	struct rsi_result result;
+
+	result = rsi_invoke(SMC_RSI_ATTESTATION_TOKEN_INIT,
+						buf,
+						challenge_0, challenge_1,
+						challenge_2, challenge_3,
+						challenge_4, challenge_5,
+						challenge_6, challenge_7,
+						0, 0);
+	if (result.err_code) {
+		return result;
+	}
+
+	do {
+		result = rsi_invoke(SMC_RSI_ATTESTATION_TOKEN_CONTINUE,
+							buf,
+							challenge_0, challenge_1,
+							challenge_2, challenge_3,
+							challenge_4, challenge_5,
+							challenge_6, challenge_7,
+							0, 0);
+	} while (result.err_code == RSI_INCOMPLETE);
+
+	return result;
+}
+
+static int cca_attestation_open(struct inode *, struct file *);
+static int cca_attestation_release(struct inode *, struct file *);
+static long cca_attestation_ioctl(struct file *f, unsigned int cmd, unsigned long arg);
+
+static struct file_operations attestation_fops = {
+    .owner = THIS_MODULE,
+    .open = cca_attestation_open,
+    .release = cca_attestation_release,
+    .unlocked_ioctl = cca_attestation_ioctl
+};
+
+int cca_attestation_open(struct inode *i, struct file *f)
+{
+#ifdef CCA_DEBUG
+	printk("cca-attestation: Attestation device open\n");
+#endif
+	return 0;
+}
+
+int cca_attestation_release(struct inode *i, struct file *f)
+{
+#ifdef CCA_DEBUG
+	printk("cca-attestation: Attestation device closed\n");
+#endif
+	return 0;
+}
+
+long cca_attestation_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
+{
+#ifdef CCA_DEBUG
+	printk("cca-attestation: Attestation device IOCTL called\n");
+#endif
+
+	switch (cmd) {
+	case CCA_ATTESTATION_REQUEST_TOKEN: {
+		cca_challenge_t challenge;
+		phys_addr_t ipa;
+		struct rsi_result result;
+		ssize_t token_length;
+
+		if (copy_from_user(
+			    (void *)&challenge,
+				(const void *)(&((cca_ioctl_attestation_request_t *)arg)->challenge),
+			    sizeof(cca_challenge_t))) {
+			return -EACCES;
+		}
+
+		if (mutex_trylock(&cca_attestation_lock) == 0) {
+			return -EAGAIN;
+		}
+
+		ipa = virt_to_phys(cca_attestation_buf);
+
+        result = get_attest_token(ipa,
+				challenge.as_long[0], challenge.as_long[1],
+				challenge.as_long[2], challenge.as_long[3],
+				challenge.as_long[4], challenge.as_long[5],
+				challenge.as_long[6], challenge.as_long[7]);
+
+		mutex_unlock(&cca_attestation_lock);
+
+		if (result.err_code) {
+			printk("cca-attestation: Attestation call failed! err_code = %08x\n", result.err_code);
+			return result.err_code;
+		}
+
+#ifdef CCA_DEBUG
+		printk("cca-attestation: Attestation call successful (token length = %ld)\n", result.x1);
+#endif
+		token_length = result.x1;
+
+#ifdef CCA_DEBUG
+		do {
+			char buf[65];
+			ssize_t cur = 0, i;
+			while (cur < token_length) {
+				buf[0] = '\0';
+				for (i = 0; i < 32 && (cur < token_length); i++) {
+					sprintf(buf + i, "%02x", cca_attestation_buf[cur]);
+					cur += 1;
+				}
+				printk("cca-attestation: %s\n", buf);
+			}
+		} while (0);
+#endif
+
+		if (copy_to_user(((cca_ioctl_attestation_request_t *)arg)->token, cca_attestation_buf, token_length)) {
+			return -EACCES;
+		}
+		if (copy_to_user(&(((cca_ioctl_attestation_request_t *)arg)->token_length), &token_length, sizeof(token_length))) {
+			return -EACCES;
+		}
+		return 0;
+	}
+
+	case CCA_MEASUREMENT_EXTEND_TOKEN: {
+
+		struct smc_result smc_result;
+		cca_ioctl_measurement_t m;
+
+		if (copy_from_user(
+			    (void *)&m,
+				(const void *)((cca_ioctl_measurement_t *)arg),
+			    sizeof(cca_ioctl_measurement_t))) {
+			return -EACCES;
+		}
+
+#ifdef CCA_DEBUG
+		printk("cca-attestation: Extend measurement %d (length = %ld)\n",
+			   m.index, m.measurement_size);
+#endif
+		smc_invoke_res(SMC_RSI_MEASUREMENT_EXTEND, m.index, m.measurement_size,
+				m.measurement.as_long[0], m.measurement.as_long[1],
+				m.measurement.as_long[2], m.measurement.as_long[3],
+				m.measurement.as_long[4], m.measurement.as_long[5],
+				m.measurement.as_long[6], m.measurement.as_long[7],
+				0, &smc_result);
+		m.result = smc_result.x0;
+#ifdef CCA_DEBUG
+		printk("cca-attestation: Extend measurement => %x\n", m.result);
+#endif
+		if (copy_to_user(&(((cca_ioctl_measurement_t *)arg)->result), &(m.result), sizeof(m.result))) {
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	case CCA_MEASUREMENT_READ_TOKEN: {
+		struct smc_result smc_result;
+		cca_ioctl_measurement_t m;
+
+		if (copy_from_user(
+			    (void *)&(m.index),
+				(const void *)(&((cca_ioctl_measurement_t *)arg)->index),
+			    sizeof(m.index))) {
+			return -EACCES;
+		}
+
+#ifdef CCA_DEBUG
+		printk("cca-attestation: Read measurement %d\n", m.index);
+#endif
+		smc_invoke_res(SMC_RSI_MEASUREMENT_READ, m.index,
+					   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &smc_result);
+
+		m.result = smc_result.x0;
+#ifdef CCA_DEBUG
+		printk("cca-attestation: Read measurement => %x\n", m.result);
+#endif
+		m.measurement.as_long[0] = smc_result.x1;
+		m.measurement.as_long[1] = smc_result.x2;
+		m.measurement.as_long[2] = smc_result.x3;
+		m.measurement.as_long[3] = smc_result.x4;
+		m.measurement.as_long[4] = smc_result.x5;
+		m.measurement.as_long[5] = smc_result.x6;
+		m.measurement.as_long[6] = smc_result.x7;
+		m.measurement.as_long[7] = smc_result.x8;
+
+		if (copy_to_user(((cca_ioctl_measurement_t *)arg), &m, sizeof(m))) {
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	default:
+		printk("cca-attestation: IOCTL cmd %08x called (expected %08lx)\n", cmd, CCA_ATTESTATION_REQUEST_TOKEN);
+#ifdef CCA_DEBUG
+		printk("cca-attestation: IOCTL dir %08x called (expected %08lx)\n", _IOC_DIR(cmd), _IOC_DIR(CCA_ATTESTATION_REQUEST_TOKEN));
+		printk("cca-attestation: IOCTL type %08x called (expected %08lx)\n", _IOC_TYPE(cmd), _IOC_TYPE(CCA_ATTESTATION_REQUEST_TOKEN));
+		printk("cca-attestation: IOCTL nr %08x called (expected %08lx)\n", _IOC_NR(cmd), _IOC_NR(CCA_ATTESTATION_REQUEST_TOKEN));
+		printk("cca-attestation: IOCTL size %08x called (expected %08lx)\n", _IOC_SIZE(cmd), _IOC_SIZE(CCA_ATTESTATION_REQUEST_TOKEN));
+#endif
+		return -EINVAL;
+	}
+}
+
+static int cca_attestation_module_init(void)
+{
+	int result;
+	int realm = is_realm_world() ? 1 : 0;
+	int startup_test = 0;
+	if (realm) {
+		printk("cca-attestation: Realm world detected. "
+			   "RSI version %08lx\n", rsi_get_version());
+	} else {
+		printk("cca-attestation: Realm world not detected!\n");
+	}
+
+	if (realm && startup_test) {
+		struct rsi_result result;
+		phys_addr_t ipa = virt_to_phys(cca_attestation_buf);
+
+        result = get_attest_token(ipa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
+		if (result.err_code) {
+			printk("cca-attestation: Attestation call failed! err_code = %08x\n", result.err_code);
+		} else {
+			printk("cca-attestation: Attestation call successful (token length = %ld)\n", result.x1);
+#ifdef CCA_DEBUG
+			do {
+				char buf[65];
+				ssize_t cur = 0, i;
+				while (cur < token_length) {
+					buf[0] = '\0';
+					for (i = 0; i < 32 && (cur < token_length); i++) {
+						sprintf(buf + i, "%02x", cca_attestation_buf[cur]);
+						cur += 1;
+					}
+					printk("cca-attestation: %s\n", buf);
+				}
+			} while (0);
+#endif
+		}
+
+	}
+
+	result = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);
+	if (result < 0) {
+		printk("cca-attestation: Character device could not be allocated!\n");
+		return result;
+	}
+	printk("cca-attestation: Character device allocated: major: %d, minor: %d\n",
+			MAJOR(dev), MINOR(dev));
+
+	cca_class = class_create(THIS_MODULE, DEVICE_CLASS);
+	if (cca_class != NULL) {
+		if (device_create(cca_class, NULL, dev, NULL, DEVICE_FILE) != NULL) {
+			cdev_init(&attestation_dev, &attestation_fops);
+
+			if (cdev_add(&attestation_dev, dev, 1) != -1) {
+				return 0;
+			}
+			printk("cca-attestation: device registration failed!\n");
+			device_destroy(cca_class, dev);
+		}
+		printk("cca-attestation: Device file creation failed!\n");
+		class_destroy(cca_class);
+	}
+
+	printk("cca-attestation: Device class creation failed!\n");
+	unregister_chrdev_region(dev, 1);
+
+	return -1;
+}
+
+module_init(cca_attestation_module_init);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("CCA Attestation driver");
diff --git a/arch/arm64/cca-attestation/rsi.h b/arch/arm64/cca-attestation/rsi.h
new file mode 100644
index 000000000000..bee3170559aa
--- /dev/null
+++ b/arch/arm64/cca-attestation/rsi.h
@@ -0,0 +1,44 @@
+#ifndef CCA_ATTESTATION_RSI_H
+#define CCA_ATTESTATION_RSI_H
+
+struct rsi_result {
+        unsigned int err_code;
+        unsigned long x1;
+        unsigned long x2;
+        unsigned long x3;
+        unsigned long x4;
+        unsigned long x5;
+        unsigned long x6;
+        unsigned long x7;
+        unsigned long x8;
+        unsigned long x9;
+};
+
+struct smc_result {
+        unsigned long x0;
+        unsigned long x1;
+        unsigned long x2;
+        unsigned long x3;
+        unsigned long x4;
+        unsigned long x5;
+        unsigned long x6;
+        unsigned long x7;
+        unsigned long x8;
+        unsigned long x9;
+};
+
+extern void smc_invoke_res(unsigned int x0,
+                           unsigned long x1,
+                           unsigned long x2,
+                           unsigned long x3,
+                           unsigned long x4,
+                           unsigned long x5,
+                           unsigned long x6,
+                           unsigned long x7,
+                           unsigned long x8,
+                           unsigned long x9,
+                           unsigned long x10,
+                           unsigned long x11,
+                           struct smc_result *results);
+
+#endif
\ No newline at end of file
diff --git a/arch/arm64/cca-attestation/smc-rsi.h b/arch/arm64/cca-attestation/smc-rsi.h
new file mode 100644
index 000000000000..69c40a567565
--- /dev/null
+++ b/arch/arm64/cca-attestation/smc-rsi.h
@@ -0,0 +1,109 @@
+/*
+ * (C) COPYRIGHT 2019, 2021 ARM Limited or its affiliates.
+ * ALL RIGHTS RESERVED
+ */
+#ifndef __SMC_RSI_H_
+#define __SMC_RSI_H_
+
+/*
+ * This file describes the Realm Services Interface (RSI) Application Binary
+ * Interface (ABI) for SMC calls made from within the Realm to the RMM and
+ * serviced by the RMM.
+ *
+ * See doc/rmm_interface.md for more details.
+ */
+
+#define SMC_RSI_CALL_BASE		0xC4000000
+
+/*
+ * The major version number of the RSI implementation.  Increase this whenever
+ * the binary format or semantics of the SMC calls change.
+ */
+#define RSI_ABI_VERSION_MAJOR		8
+
+/*
+ * The minor version number of the RSI implementation.  Increase this when
+ * a bug is fixed, or a feature is added without breaking binary compatibility.
+ */
+#define RSI_ABI_VERSION_MINOR		0
+
+#define RSI_ABI_VERSION			((RSI_ABI_VERSION_MAJOR << 16) | \
+					 RSI_ABI_VERSION_MINOR)
+
+#define RSI_ABI_VERSION_GET_MAJOR(_version) ((_version) >> 16)
+#define RSI_ABI_VERSION_GET_MINOR(_version) ((_version) & 0xFFFF)
+
+#define RSI_SUCCESS			0
+#define RSI_ERROR_INPUT			1
+#define RSI_ERROR_STATE			2
+#define RSI_INCOMPLETE			3
+
+#define SMC_RSI_FID(_x)			(SMC_RSI_CALL_BASE + (_x))
+
+#define SMC_RSI_ABI_VERSION			SMC_RSI_FID(0x190)
+
+/*
+ * arg0 == IPA address
+ * arg1 == size of the disposed region
+ */
+#define SMC_RSI_MEMORY_DISPOSE			SMC_RSI_FID(0x191)
+
+/*
+ * arg1 == The IPA of token buffer
+ * arg2 == Challenge value, bytes:  0 -  7
+ * arg3 == Challenge value, bytes:  7 - 15
+ * arg4 == Challenge value, bytes: 16 - 23
+ * arg5 == Challenge value, bytes: 24 - 31
+ * arg6 == Challenge value, bytes: 32 - 39
+ * arg7 == Challenge value, bytes: 40 - 47
+ * arg8 == Challenge value, bytes: 48 - 55
+ * arg9 == Challenge value, bytes: 56 - 63
+ * ret0 == Status / error
+ */
+#define SMC_RSI_ATTEST_TOKEN_INIT	SMC_RSI_FID(0x192)
+
+/*
+ * arg1 == The IPA of token buffer
+ * arg2 == Challenge value, bytes:  0 -  7
+ * arg3 == Challenge value, bytes:  7 - 15
+ * arg4 == Challenge value, bytes: 16 - 23
+ * arg5 == Challenge value, bytes: 24 - 31
+ * arg6 == Challenge value, bytes: 32 - 39
+ * arg7 == Challenge value, bytes: 40 - 47
+ * arg8 == Challenge value, bytes: 48 - 55
+ * arg9 == Challenge value, bytes: 56 - 63
+ * ret0 == Status / error
+ * ret1 == Size of completed token in bytes
+ */
+#define SMC_RSI_ATTEST_TOKEN_CONTINUE	SMC_RSI_FID(0x193)
+
+/*
+ * arg1  == Index, which measurements slot to extend
+ * arg2  == Size of realm measurement in bytes, max 64 bytes
+ * arg3  == Measurement value, bytes:  0 -  7
+ * arg4  == Measurement value, bytes:  7 - 15
+ * arg5  == Measurement value, bytes: 16 - 23
+ * arg6  == Measurement value, bytes: 24 - 31
+ * arg7  == Measurement value, bytes: 32 - 39
+ * arg8  == Measurement value, bytes: 40 - 47
+ * arg9  == Measurement value, bytes: 48 - 55
+ * arg10 == Measurement value, bytes: 56 - 63
+ * ret0  == Status / error
+ */
+#define SMC_RSI_MEASUREMENT_EXTEND	SMC_RSI_FID(0x194)
+
+/*
+ * arg1 == Index, which measurements slot to read
+ * ret0 == Status / error
+ * ret1 == Measurement value, bytes:  0 -  7
+ * ret2 == Measurement value, bytes:  7 - 15
+ * ret3 == Measurement value, bytes: 16 - 23
+ * ret4 == Measurement value, bytes: 24 - 31
+ * ret5 == Measurement value, bytes: 32 - 39
+ * ret6 == Measurement value, bytes: 40 - 47
+ * ret7 == Measurement value, bytes: 48 - 55
+ * ret8 == Measurement value, bytes: 56 - 63
+ */
+#define SMC_RSI_MEASUREMENT_READ	SMC_RSI_FID(0x195)
+
+#endif /* __SMC_RSI_H_ */
diff --git a/arch/arm64/cca-attestation/smc.S b/arch/arm64/cca-attestation/smc.S
new file mode 100644
index 000000000000..930845b6a0af
--- /dev/null
+++ b/arch/arm64/cca-attestation/smc.S
@@ -0,0 +1,113 @@
+/*
+ * (c) copyright 2020 arm limited or its affiliates.
+ * all rights reserved
+ */
+
+/*
+ * extern unsigned int smc_invoke(unsigned int x0,
+ * 			       unsigned long x1,
+ * 			       unsigned long x2,
+ * 			       unsigned long x3);
+ */
+
+.global smc_invoke
+smc_invoke:
+	/* As this is a function call, the arguments must already be in
+	 * place in accordance to SMCCC.
+	 */
+	smc #0
+	ret
+
+
+/*
+ * Call this version when you might need more than x0 back as a result.
+ *
+ * We take advantage of the fact that the first 8 arguments (passed in x0
+ * through x7) use the registers, and the next argument is pushed to the
+ * stack. That means, we can get to the address of the results structure by
+ * loading from the sp, even if the callee doesn't implement SMCCC for
+ * example.
+ *
+ * struct smc_result {
+ * 	unsigned long x0;
+ * 	unsigned long x1;
+ * 	unsigned long x2;
+ * 	unsigned long x3;
+ * 	unsigned long x4;
+ * };
+ *
+ * extern void smc_invoke_res(unsigned int x0,
+ * 			      unsigned long x1,
+ * 			      unsigned long x2,
+ * 			      unsigned long x3,
+ * 			      unsigned long x4,
+ * 			      unsigned long x5,
+ * 			      unsigned long x6,
+ * 			      unsigned long x7,
+ * 			      unsigned long x8,
+ * 			      unsigned long x9,
+ * 			      unsigned long x10,
+ * 			      unsigned long x11,
+ * 			      struct smc_result *results);
+ */
+.global smc_invoke_res
+smc_invoke_res:
+	/* As this is a function call, the arguments must already be in
+	 * place in accordance to SMCCC. X0-X7 in registers the rest is on the
+	 * stack.
+	 */
+	/* Store x8-x11 original content to the stack */
+	stp x9, x8,   [sp, #-16]!
+	stp x11, x10, [sp, #-16]!
+	/* Load arguments from stack to x8-x11 */
+	ldp x8, x9,   [sp, #32]
+	ldp x10, x11, [sp, #48]
+	smc #0
+	/* Get result address */
+	ldr x10, [sp, #64]
+	/* Fill result structure */
+	stp x0, x1, [x10, #0]
+	stp x2, x3, [x10, #16]
+	stp x4, x5, [x10, #32]
+	stp x6, x7, [x10, #48]
+	stp x8, x9, [x10, #64]
+
+	/* Restore x8-x11 original content from the stack */
+	ldp x11, x10, [sp], #16
+	ldp x9, x8,   [sp], #16
+	ret
+
+/*
+ * extern void hvc_invoke_res(unsigned int x0,
+ *                            unsigned long x1,
+ *                            unsigned long x2,
+ *                            unsigned long x3,
+ *                            unsigned long x4,
+ *                            unsigned long x5,
+ *                            unsigned long x6,
+ *                            unsigned long x7,
+ *                            struct smc_result *results);
+ */
+.global hvc_invoke_res
+hvc_invoke_res:
+       hvc #0
+       ldr x5, [sp]
+       stp x0, x1, [x5, #0]
+       stp x2, x3, [x5, #16]
+       str x4, [x5, #32]
+       ret
+
+/*
+ * extern unsigned int hvc_invoke(unsigned int x0,
+ * 				  unsigned long x1,
+ * 				  unsigned long x2,
+ * 				  unsigned long x3);
+ */
+
+.global hvc_invoke
+hvc_invoke:
+	/* As this is a function call, the arguments must already be in
+	 * place in accordance to SMCCC.
+	 */
+	hvc #0
+	ret
\ No newline at end of file
